# shamelessly copied from https://github.com/ferbar/esphome-configs/tree/main/config
effects:
  - addressable_random_twinkle:
      name: Random Twinkle
  - addressable_twinkle:
      name: Random Twinkle 5%
      twinkle_probability: 5%
      progress_interval: 12ms
  - addressable_random_twinkle:
      name: Random Twinkle 20%
      twinkle_probability: 20%
      progress_interval: 32ms
  - addressable_random_twinkle:
      name: Random Twinkle 80%
      twinkle_probability: 80%
      progress_interval: 32ms
  - addressable_scan:
      name: Scan
      move_interval: 300ms
      scan_width: 4
  - addressable_color_wipe:
      name: Color Wipe
  - addressable_rainbow:
      name: Rainbow
  - addressable_fireworks:
      name: Fireworks
      update_interval: 32ms
      spark_probability: 20%
      use_random_color: true
      fade_out_rate: 120
  - addressable_lambda:
      name: "Christmas RedGreenWhite"
      lambda: |-
        static uint8_t *xLedInc=NULL;
        static int *xLedDim=NULL; // -255 ... 255
        static esphome::Color *xLedColor=NULL;
        // ..... creates compiler warning .....
        #define getColor() \
            esphome::Color color; \
            switch( (int) floor( random_uint32() / (double(UINT32_MAX)+1) * 3)) { \
              case 0: color=esphome::Color(255, 0, 18); break; \
              case 1: color=esphome::Color(0, 179, 44); break; \
              default: color=esphome::Color(255, 255, 255); break; \
            } \
            int dim=127+random_float()*128; \
            xLedColor[i]=color*dim;

        if(xLedInc==NULL) {
          xLedInc=new uint8_t[it.size()];
          xLedDim=new int[it.size()];
          xLedColor=new esphome::Color[it.size()];
          for(int i=0; i < it.size(); i++) {
            xLedInc[i]=random_float()*8;
            xLedDim[i]=random_float()*511-255;
            getColor();
            // ESP_LOGD(TAG, "init [%d]=> b:%d %02x %02x %02x   => %02x %02x %02x", i, dim, color.red, color.green, color.blue,  xLedColor[i].red,  xLedColor[i].green,  xLedColor[i].blue);
          }
        }
        for (int i = 0; i <  it.size(); i++) {
          int dim=255 - abs(xLedDim[i]);
          esphome::Color color=xLedColor[i] * dim;
          // if(i==0) ESP_LOGD(TAG, "[0]=> b:%d %02x %02x %02x",dim, color.red, color.green, color.blue);
          it[i] = color;
          xLedDim[i]+=xLedInc[i];
          if(xLedDim[i] > 255) {
            xLedDim[i]=-255;
            getColor();
          }
        }
  - addressable_lambda:
      name: "color change"
      lambda: |-
        static esphome::Color *xLedTargetColor=NULL;
        static esphome::Color *xLedCurrColor=NULL;

        if(xLedTargetColor==NULL) {
          xLedTargetColor=new esphome::Color[it.size()];
          xLedCurrColor=new esphome::Color[it.size()];
          for(int i=0; i < it.size(); i++) {
            xLedCurrColor[i]=it[i].get();
            xLedTargetColor[i]=esphome::Color::random_color();
            // esphome::Color target= xLedTargetColor[i];
            // ESP_LOGD(TAG, "init [%d]=> %02x %02x %02x", i, target.red, target.green, target.blue);
          }
        }
        for (int i = 0; i <  it.size(); i++) {
          esphome::Color &c=xLedCurrColor[i];
          esphome::Color org=c;
          esphome::Color target= xLedTargetColor[i];
          if(c.red == target.red && c.green == target.green && c.blue == target.blue) {
            xLedTargetColor[i]=esphome::Color::random_color();
            // target= xLedTargetColor[i];
            // ESP_LOGD(TAG, "init [%d]=> %02x %02x %02x", i, target.red, target.green, target.blue);
          }
          if(c.red < target.red) {
            c.red++;
          } else if(c.red > target.red) {
            c.red--;
          }
          if(c.green < target.green) {
            c.green++;
          } else if(c.green > target.green) {
            c.green--;
          }
          if(c.blue < target.blue) {
            c.blue++;
          } else if(c.blue > target.blue) {
            c.blue--;
          }
          // ESP_LOGD(TAG, "change [%d]=> %02x %02x %02x  => %02x %02x %02x", i, c.red, c.green, c.blue, target.red, target.green, target.blue);
        //            it[i].set_red(c.red+2);
        //            it[i].set_green(c.green+2);
        //            it[i].set_blue(c.blue);
          // esphome::Color x(c.red, c.green, c.blue);
          // esphome::Color x(10, 30, 60);
          it[i] = c;
          // if(i==0) ESP_LOGD(TAG, "change [%d]=> %02x %02x %02x  => %02x %02x %02x", i, org.red, org.green, org.blue,  it[i].get_red(), it[i].get_green(), it[i].get_blue());
        }
  - addressable_lambda:
      name: "random shift"
      update_interval: 16ms
      lambda: |-
        // it.size() - Number of LEDs
        // it[num] - Access the LED at index num.
        // Set the LED at num to the given r, g, b values
        // it[num] = esphome::Color(r, g, b);
        // Get the color at index num (esphome::Color instance)
        // it[num].get();

        // Example: Simple color wipe
        // every 3rd led ...
        if(random_float() > 0.7)
          it[0] = esphome::Color::random_color();
        else
           it[0] = Color::BLACK;
        for (int i = it.size() -1 ; i > 0; i--) {
          it[i] = it[i - 1].get();
        }

        // Bonus: use .range() and .all() to set many LEDs without having to write a loop.
        //it.range(0, 50) = Color::BLACK;
        //it.all().fade_to_black(10);

  - addressable_lambda:
      name: "starry sky"
      update_interval: 10ms
      lambda: |-
        starsLambda(it);

  - addressable_lambda:
      name: "candles"
      update_interval: 16ms
      lambda: |-
        const int STAR_K_NORM_MIN=1900;
        const int STAR_K_NORM_MAX=3000;
        const int STAR_K_DISTURBED_MIN=1700;
        const int STAR_K_DISTURBED_MAX=7500;
        static int *target=NULL;
        static int *curr=NULL;
        static int *inc=NULL;
        static int *state=NULL;
        static int *startState=NULL;
        static int *stateLen=NULL;
        static esphome::Color *targetColor=NULL;
        static esphome::Color *currColor=NULL;

        // ESP_LOGD(TAG, "candle");
        if(state==NULL) {
          // ESP_LOGD(TAG, "candle mallocs");
          target=new int[it.size()];
          curr=new int[it.size()];
          inc=new int[it.size()];
          state=new int[it.size()];
          startState=new int[it.size()];
          stateLen=new int[it.size()];
          targetColor=new esphome::Color[it.size()];
          currColor=new esphome::Color[it.size()];
          // ESP_LOGD(TAG, "candle mallocs done");
        }
        if(initial_run) {
          // ESP_LOGD(TAG, "candle initial_run");
          for(int i=0; i < it.size(); i++) {
            // ESP_LOGD(TAG, "candle initial_run[%d]", i); delay(10);
            curr[i]=0; target[i]=0; // curr==target => init
            inc[i]=0; state[i]=0; startState[i]=0; stateLen[i]=0;
            currColor[i] = it[i].get();
            targetColor[i] = it[i].get();
          }
          // ESP_LOGD(TAG, "candle initial_run done"); delay(10);
        }
        for (int i = 0; i < it.size() ; i++) {
          // ESP_LOGD(TAG, "candle [%d]", i); delay(10);
          if(state[i] == 0 || state[i] > 500) {
            state[i] = random(500); // random delay till first flicker
            target[i] = curr[i]; // init new target
          }
          // set new target if target reached
          if(state[i] == 450 || (curr[i] == target[i] && state[i] > 450)) { // 10% is disturbed candle
            target[i]=random(50, 255);
            inc[i]=random(50)+1;
            currColor[i]=targetColor[i];
            // targetColor[i]=current_color+esphome::Color::random_color()*random(100);
            int k=(random_float() * (STAR_K_DISTURBED_MAX-STAR_K_DISTURBED_MIN) )+STAR_K_DISTURBED_MIN; // 1800K - 7500K
            targetColor[i] = colorTemperatureToRGB(k);
            stateLen[i]=abs(target[i]-curr[i]) / inc[i];
            startState[i]=state[i];
          } else if(curr[i] == target[i]) { // slow changing candle
            target[i]=random(80, 160);
            inc[i]=random(10)+1;
            currColor[i]=targetColor[i];
            // targetColor[i]=current_color+esphome::Color::random_color()*random(40);
            int k=(random_float() * (STAR_K_NORM_MAX-STAR_K_NORM_MIN) )+STAR_K_NORM_MIN; // 2200K - 6000K
            targetColor[i] = colorTemperatureToRGB(k);
            stateLen[i]=abs(target[i]-curr[i]) / inc[i];
            startState[i]=state[i];
          }
          // ESP_LOGD(TAG, "candle [%d]2", i); delay(10);
          if(curr[i] > target[i]) {
            curr[i]-=min(inc[i], curr[i]-target[i]);
          } else {
            curr[i]+=min(inc[i], target[i]-curr[i]);
          }
          // ESP_LOGD(TAG, "candle [%d]3", i); delay(10);
          int factor=255;
          if(stateLen[i] > 0) factor = 255 * (state[i] - startState[i]) / (stateLen[i]);
          esphome::Color c=currColor[i]*(factor*(curr[i]+1)/256) + targetColor[i]*((255-factor)*(curr[i]+1)/256);
          it[i]=c;
          // it[i]=it[i]*curr[i];
          state[i]++;
          // if(i==0) ESP_LOGD(TAG, "candle [0]=> t:%d c:%d inc:%d state:%d startState:%d stateLen:%d factor:%d cc:%02x tc:%02x out=%02x",
          //  target[i], curr[i], inc[i], state[i], startState[i], stateLen[i],
          //  factor, currColor[i].red, targetColor[i].red, c.red);
        }
  - addressable_lambda:
      name: "flicker"
      update_interval: 16ms
      lambda: |-
        static int *target=NULL;
        static int *curr=NULL;
        static int *inc=NULL;
        static int *state=NULL;
        static int *startState=NULL;
        static int *stateLen=NULL;
        static esphome::Color *targetColor=NULL;
        static esphome::Color *currColor=NULL;

        // ESP_LOGD(TAG, "flicker");
        if(state==NULL) {
          // ESP_LOGD(TAG, "flicker mallocs");
          target=new int[it.size()];
          curr=new int[it.size()];
          inc=new int[it.size()];
          state=new int[it.size()];
          startState=new int[it.size()];
          stateLen=new int[it.size()];
          targetColor=new esphome::Color[it.size()];
          currColor=new esphome::Color[it.size()];
          // ESP_LOGD(TAG, "flicker mallocs done");
        }
        if(initial_run) {
          // ESP_LOGD(TAG, "flicker initial_run");
          for(int i=0; i < it.size(); i++) {
            // ESP_LOGD(TAG, "flicker initial_run[%d]", i); delay(10);
            curr[i]=0; target[i]=0; // curr==target => init
            inc[i]=0; state[i]=0; startState[i]=0; stateLen[i]=0;
            currColor[i] = it[i].get();
            targetColor[i] = it[i].get();
          }
          // ESP_LOGD(TAG, "flicker initial_run done"); delay(10);
        }
        for (int i = 0; i < it.size() ; i++) {
          // ESP_LOGD(TAG, "flicker [%d]", i); delay(10);
          if(state[i] == 0 || state[i] > 500) {
            state[i] = random(500); // random delay till first flicker
            target[i] = curr[i]; // init new target
          }
          // set new target if target reached
          if(state[i] == 450 || (curr[i] == target[i] && state[i] > 450)) { // 10% is disturbed candle
            target[i]=random(50, 255);
            inc[i]=random(50)+1;
            currColor[i]=targetColor[i];
            targetColor[i]=current_color+esphome::Color::random_color()*random(100);
            stateLen[i]=abs(target[i]-curr[i]) / inc[i];
            startState[i]=state[i];
          } else if(curr[i] == target[i]) { // slow changing candle
            target[i]=random(80, 160);
            inc[i]=random(10)+1;
            currColor[i]=targetColor[i];
            targetColor[i]=current_color+esphome::Color::random_color()*random(40);
            stateLen[i]=abs(target[i]-curr[i]) / inc[i];
            startState[i]=state[i];
          }
          // ESP_LOGD(TAG, "flicker [%d]2", i); delay(10);
          if(curr[i] > target[i]) {
            curr[i]-=min(inc[i], curr[i]-target[i]);
          } else {
            curr[i]+=min(inc[i], target[i]-curr[i]);
          }
          // ESP_LOGD(TAG, "flicker [%d]3", i); delay(10);
          int factor=255;
          if(stateLen[i] > 0) factor = 255 * (state[i] - startState[i]) / (stateLen[i]);
          esphome::Color c=currColor[i]*(factor*(curr[i]+1)/256) + targetColor[i]*((255-factor)*(curr[i]+1)/256);
          it[i]=c;
          // it[i]=it[i]*curr[i];
          state[i]++;
          // if(i==0) ESP_LOGD(TAG, "flicker [0]=> t:%d c:%d inc:%d state:%d startState:%d stateLen:%d factor:%d cc:%02x tc:%02x out=%02x",
          //  target[i], curr[i], inc[i], state[i], startState[i], stateLen[i],
          //  factor, currColor[i].red, targetColor[i].red, c.red);
        }
