substitutions:
  # lichterkette christbaum
  devicename: "esp32_3"
  upper_devicename: "ESP32 3"

globals:
  - id: current_effect
    type: int
    restore_value: yes
    initial_value: "0"

<<: !include common/esp32.yaml

esphome:
  name: $devicename
  platform: esp32
  board: az-delivery-devkit-v4
  # includes:
  # - lambdas/colorTempToRGB.h
  # - lambdas/starsLambda.h
  on_boot:
    priority: 800
    then:
      - light.turn_on:
          id: WS2812b
          # effect unten beim turn on handler einstellen!
          brightness: 50%

sensor:
  - !include common/base-sensor-wifi.yaml
  - !include common/base-sensor-uptime.yaml
  - platform: adc
    # pin: A0
    # use an ADC1 pin
    pin: GPIO34
    # kein name, da internal
    id: "set_brightness"
    internal: true
    filters:
      - calibrate_linear:
          - 0.0 -> 0.0
          - 3.3 -> 1.0
      - lambda: |-
          return x;
      - delta: 0.05
    attenuation: auto
    update_interval: 200ms
    on_value:
      then:
        if:
          condition:
            light.is_on: WS2812b
          then:
            # - logger.log:
            #     format: "Stored value set to: %.1f"
            #     args: ["id(set_brightness).state"]
            #     level: INFO
            - light.turn_on:
                id: WS2812b
                brightness: !lambda |-
                  return x;
            # - homeassistant.service:
            #    service: light.turn_on
            #    data:
            #      entity_id: light.esp32_3_licht
            #      brightness: !lambda |-
            #        return (int)x;

binary_sensor:
  - !include common/base-binarysensor-status.yaml
  # light on/off button
  - platform: gpio
    device_class: light
    name: "${devicename} - Button 1"
    id: "button_1"
    pin:
      number: GPIO32
      mode: INPUT_PULLUP
      # inverted: True
    on_press:
      - light.toggle: "WS2812b"

  # light effect switch button
  - platform: gpio
    device_class: light
    name: "${devicename} - Button 2"
    id: "button_2"
    pin:
      number: GPIO25
      mode: INPUT_PULLUP
    on_press:
      - lambda: |-
          auto call = id(WS2812b).turn_on();

          if (id(current_effect) == 0)
            call.set_effect("Random Twinkle");
          else if (id(current_effect) == 1)
            call.set_effect("Random Twinkle 5%");
          else if (id(current_effect) == 2)
            call.set_effect("Random Twinkle 20%");
          else if (id(current_effect) == 3)
            call.set_effect("Random Twinkle 80%");
          else if (id(current_effect) == 4)
            call.set_effect("Scan");
          else if (id(current_effect) == 5)
            call.set_effect("Color Wipe");
          else if (id(current_effect) == 6)
            call.set_effect("Rainbow");
          else if (id(current_effect) == 7)
            call.set_effect("Fireworks");

          else {
              call.set_effect("None");
              id(current_effect) = -1;
          }

          id(current_effect) += 1;
          call.perform();

light:
  - platform: fastled_clockless
    name: "$devicename - Licht"
    icon: mdi:led-outline
    chipset: WS2811
    # pin: D1
    # use an U2 TX pin
    pin: GPIO17
    num_leds: 100
    # rgb_order: BRG
    # rgb_order: GRB
    rgb_order: RGB
    # disable on_turn on handler because brightness adc will call it often
    # on_turn_on:
    #  - light.turn_on:
    #      id: WS2812b
    # effect: "Random Twinkle 20%"
    #      effect: None
    # effect: "starry sky"
    # effect: "candles"
    # red: 1
    # green: 0.75
    # blue: 0.2
    # effect: "color change"
    id: WS2812b
    effects:
      - addressable_random_twinkle:
          name: Random Twinkle
      - addressable_random_twinkle:
          name: Random Twinkle 20%
          twinkle_probability: 20%
          progress_interval: 32ms
      - addressable_random_twinkle:
          name: Random Twinkle 80%
          twinkle_probability: 80%
          progress_interval: 32ms
      - addressable_twinkle:
          name: Random Twinkle 5%
          twinkle_probability: 5%
          progress_interval: 12ms
      - addressable_scan:
          name: Scan
          move_interval: 200ms
          scan_width: 4
      - addressable_color_wipe:
          name: Color Wipe
      - addressable_rainbow:
          name: Rainbow
      - addressable_fireworks:
          name: Fireworks
          update_interval: 32ms
          spark_probability: 20%
          use_random_color: true
          fade_out_rate: 120
      # - addressable_lambda:
      #     name: "Christmas RedGreenWhite"
      #     lambda: |-
      #       static uint8_t *xLedInc=NULL;
      #       static int *xLedDim=NULL; // -255 ... 255
      #       static Color *xLedColor=NULL;
      #       // ..... creates compiler warning .....
      #       #define getColor() \
      #           Color color; \
      #           switch( (int) floor( random_uint32() / (double(UINT32_MAX)+1) * 3)) { \
      #             case 0: color=Color(255, 0, 18); break; \
      #             case 1: color=Color(0, 179, 44); break; \
      #             default: color=Color(255, 255, 255); break; \
      #           } \
      #           int dim=127+random_float()*128; \
      #           xLedColor[i]=color*dim;

      #       if(xLedInc==NULL) {
      #         xLedInc=new uint8_t[it.size()];
      #         xLedDim=new int[it.size()];
      #         xLedColor=new Color[it.size()];
      #         for(int i=0; i < it.size(); i++) {
      #           xLedInc[i]=random_float()*8;
      #           xLedDim[i]=random_float()*511-255;
      #           getColor();
      #           // ESP_LOGD(TAG, "init [%d]=> b:%d %02x %02x %02x   => %02x %02x %02x", i, dim, color.red, color.green, color.blue,  xLedColor[i].red,  xLedColor[i].green,  xLedColor[i].blue);
      #         }
      #       }
      #       for (int i = 0; i <  it.size(); i++) {
      #         int dim=255 - abs(xLedDim[i]);
      #         Color color=xLedColor[i] * dim;
      #         // if(i==0) ESP_LOGD(TAG, "[0]=> b:%d %02x %02x %02x",dim, color.red, color.green, color.blue);
      #         it[i] = color;
      #         xLedDim[i]+=xLedInc[i];
      #         if(xLedDim[i] > 255) {
      #           xLedDim[i]=-255;
      #           getColor();
      #         }
      #       }

      # - addressable_lambda:
      #     name: "color change"
      #     lambda: |-
      #       static Color *xLedTargetColor=NULL;
      #       static Color *xLedCurrColor=NULL;

      #       if(xLedTargetColor==NULL) {
      #         xLedTargetColor=new Color[it.size()];
      #         xLedCurrColor=new Color[it.size()];
      #         for(int i=0; i < it.size(); i++) {
      #           xLedCurrColor[i]=it[i].get();
      #           xLedTargetColor[i]=Color::random_color();
      #           // Color target= xLedTargetColor[i];
      #           // ESP_LOGD(TAG, "init [%d]=> %02x %02x %02x", i, target.red, target.green, target.blue);
      #         }
      #       }
      #       for (int i = 0; i <  it.size(); i++) {
      #         Color &c=xLedCurrColor[i];
      #         Color org=c;
      #         Color target= xLedTargetColor[i];
      #         if(c.red == target.red && c.green == target.green && c.blue == target.blue) {
      #           xLedTargetColor[i]=Color::random_color();
      #           // target= xLedTargetColor[i];
      #           // ESP_LOGD(TAG, "init [%d]=> %02x %02x %02x", i, target.red, target.green, target.blue);
      #         }
      #         if(c.red < target.red) {
      #           c.red++;
      #         } else if(c.red > target.red) {
      #           c.red--;
      #         }
      #         if(c.green < target.green) {
      #           c.green++;
      #         } else if(c.green > target.green) {
      #           c.green--;
      #         }
      #         if(c.blue < target.blue) {
      #           c.blue++;
      #         } else if(c.blue > target.blue) {
      #           c.blue--;
      #         }
      #         // ESP_LOGD(TAG, "change [%d]=> %02x %02x %02x  => %02x %02x %02x", i, c.red, c.green, c.blue, target.red, target.green, target.blue);
      #         //            it[i].set_red(c.red+2);
      #         //            it[i].set_green(c.green+2);
      #         //            it[i].set_blue(c.blue);
      #         // Color x(c.red, c.green, c.blue);
      #         // Color x(10, 30, 60);
      #         it[i] = c;
      #         // if(i==0) ESP_LOGD(TAG, "change [%d]=> %02x %02x %02x  => %02x %02x %02x", i, org.red, org.green, org.blue,  it[i].get_red(), it[i].get_green(), it[i].get_blue());
      #       }

      # - addressable_lambda:
      #     name: "random shift"
      #     update_interval: 16ms
      #     lambda: |-
      #       // it.size() - Number of LEDs
      #       // it[num] - Access the LED at index num.
      #       // Set the LED at num to the given r, g, b values
      #       // it[num] = Color(r, g, b);
      #       // Get the color at index num (Color instance)
      #       // it[num].get();

      #       // Example: Simple color wipe
      #       // every 3rd led ...
      #       if(random_float() > 0.7)
      #         it[0] = Color::random_color();
      #       else
      #           it[0] = Color::BLACK;
      #       for (int i = it.size() -1 ; i > 0; i--) {
      #         it[i] = it[i - 1].get();
      #       }

      #       // Bonus: use .range() and .all() to set many LEDs without having to write a loop.
      #       //it.range(0, 50) = Color::BLACK;
      #       //it.all().fade_to_black(10);

      # - addressable_lambda:
      #     name: "candles"
      #     update_interval: 16ms
      #     lambda: |-
      #       static int *target=NULL;
      #       static int *curr=NULL;
      #       static int *inc=NULL;
      #       static int *state=NULL;
      #       static int *startState=NULL;
      #       static int *stateLen=NULL;
      #       static Color *targetColor=NULL;
      #       static Color *currColor=NULL;

      #       // ESP_LOGD(TAG, "candle");
      #       if(state==NULL) {
      #         // ESP_LOGD(TAG, "candle mallocs");
      #         target=new int[it.size()];
      #         curr=new int[it.size()];
      #         inc=new int[it.size()];
      #         state=new int[it.size()];
      #         startState=new int[it.size()];
      #         stateLen=new int[it.size()];
      #         targetColor=new Color[it.size()];
      #         currColor=new Color[it.size()];
      #         // ESP_LOGD(TAG, "candle mallocs done");
      #       }
      #       if(initial_run) {
      #         // ESP_LOGD(TAG, "candle initial_run");
      #         for(int i=0; i < it.size(); i++) {
      #           // ESP_LOGD(TAG, "candle initial_run[%d]", i); delay(10);
      #           curr[i]=0; target[i]=0; // curr==target => init
      #           inc[i]=0; state[i]=0; startState[i]=0; stateLen[i]=0;
      #           currColor[i] = it[i].get();
      #           targetColor[i] = it[i].get();
      #         }
      #         // ESP_LOGD(TAG, "candle initial_run done"); delay(10);
      #       }
      #       for (int i = 0; i < it.size() ; i++) {
      #         // ESP_LOGD(TAG, "candle [%d]", i); delay(10);
      #         if(state[i] == 0 || state[i] > 500) {
      #           state[i] = random(500); // random delay till first flicker
      #           target[i] = curr[i]; // init new target
      #         }
      #         // set new target if target reached
      #         if(state[i] == 450 || (curr[i] == target[i] && state[i] > 450)) { // 10% is disturbed candle
      #           target[i]=random(50, 255);
      #           inc[i]=random(50)+1;
      #           currColor[i]=targetColor[i];
      #           targetColor[i]=current_color+Color::random_color()*random(100);
      #           stateLen[i]=abs(target[i]-curr[i]) / inc[i];
      #           startState[i]=state[i];
      #         } else if(curr[i] == target[i]) { // slow changing candle
      #           target[i]=random(80, 160);
      #           inc[i]=random(10)+1;
      #           currColor[i]=targetColor[i];
      #           targetColor[i]=current_color+Color::random_color()*random(40);
      #           stateLen[i]=abs(target[i]-curr[i]) / inc[i];
      #           startState[i]=state[i];
      #         }
      #         // ESP_LOGD(TAG, "candle [%d]2", i); delay(10);
      #         if(curr[i] > target[i]) {
      #           curr[i]-=min(inc[i], curr[i]-target[i]);
      #         } else {
      #           curr[i]+=min(inc[i], target[i]-curr[i]);
      #         }
      #         // ESP_LOGD(TAG, "candle [%d]3", i); delay(10);
      #         int factor=255;
      #         if(stateLen[i] > 0) factor = 255 * (state[i] - startState[i]) / (stateLen[i]);
      #         Color c=currColor[i]*(factor*(curr[i]+1)/256) + targetColor[i]*((255-factor)*(curr[i]+1)/256);
      #         it[i]=c;
      #         // it[i]=it[i]*curr[i];
      #         state[i]++;
      #         // if(i==0) ESP_LOGD(TAG, "candle [0]=> t:%d c:%d inc:%d state:%d startState:%d stateLen:%d factor:%d cc:%02x tc:%02x out=%02x",
      #         //  target[i], curr[i], inc[i], state[i], startState[i], stateLen[i],
      #         //  factor, currColor[i].red, targetColor[i].red, c.red);
      #       }

      # - addressable_lambda:
      #     name: "starry sky"
      #     update_interval: 10ms
      #     lambda: |-
      #       starsLambda(it);

status_led:
  pin:
    number: GPIO02
    #inverted: True
    inverted: False
  id: led_blue
